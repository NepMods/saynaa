# === Top-level Makefile for Saynaa with module scaffolding ===

# Compiler for main program
CXX      := g++
CC       := gcc
CXXFLAGS := -std=c++20 -Wall -Wextra -g
CFLAGS   := -Wall -Wextra -g

# Main sources for the core compiler
MAIN_SRC := main.cpp
SRC_CPP := utils/utils.cpp utils/debug.cpp
SRC_C   := modules/register.c

# Discover one-level deep module directories within custom_modules
MODULE_DIRS := $(shell find custom_modules -mindepth 1 -maxdepth 1 -type d)

# Extra sources from custom_modules that are not built into static libraries
CUSTOM_CPP := $(shell find custom_modules -type f -name '*.cpp')
CUSTOM_C   := $(shell find custom_modules -type f -name '*.c')

# Object file targets (preserve subdirectories)
OBJ_CPP := $(patsubst %.cpp,build/%.o,$(SRC_CPP))
MAIN_OBJ := build/main.o

OBJ_C   := $(foreach f,$(SRC_C),build/$(f:.c=.o))


# All static libraries generated by individual modules
STATIC_LIBS := $(shell find custom_modules -name 'lib*.a')

# Final executable binary name
OUT := compiler

# Conditional variable for sed in-place editing, for cross-platform compatibility
ifeq ($(shell uname), Darwin)
    SED_INPLACE := -i ''
else
    SED_INPLACE := -i
endif

.PHONY: all
all: modules $(OUT)
	@echo "✓ First build pass complete."
	@$(MAKE) rebuild_main
	@echo "✓ IF ./compiler DOESNT WORK (WHICH MAY NOT WORK AFTER make clean OR FRESH BUILD, RUN make rebuild_main)"

# ------------------------------------------------------------------------------
# 1) Scan, verify, and build modules by priority
# ------------------------------------------------------------------------------
.PHONY: modules
modules:
	@echo "→ Scanning modules and verifying dependencies…"
	@rm -f /tmp/modules_info.txt
	@for d in $(MODULE_DIRS); do \
		info="$$d/module.info"; \
		if [ -f $$info ]; then \
			name=$$(grep '^name' $$info | cut -d= -f2 | xargs); \
			pr=$$(grep '^priority' $$info | cut -d= -f2 | xargs); \
			deps=$$(grep '^depends' $$info | cut -d= -f2 | xargs); \
			echo "$$name|$$pr|$$deps|$$d" >> /tmp/modules_info.txt; \
		fi; \
	done
	@while IFS='|' read mod pr deps dir; do \
		for dep in $$deps; do \
			[ -z "$$dep" ] && continue; \
			grep -q "^$$dep|" /tmp/modules_info.txt || { \
				echo "Error: Module '$$mod' depends on missing module '$$dep'"; exit 1; }; \
			dep_pr=$$(grep "^$$dep|" /tmp/modules_info.txt | cut -d'|' -f2 | xargs); \
			if [ "$$dep_pr" -ge "$$pr" ]; then \
				echo "Error: Module '$$mod' (priority $$pr) depends on '$$dep' with priority $$dep_pr, which is not lower."; exit 1; \
			fi; \
		done; \
	done < /tmp/modules_info.txt
	@echo "→ Building modules by priority…"
	@sort -t'|' -k2 -n /tmp/modules_info.txt | while IFS='|' read mod pr deps dir; do \
		echo -n "   • [$$pr] Building module: $$mod ... "; \
		logfile="/tmp/build_$$mod.log"; \
		if ( cd $$dir && $(MAKE) --no-print-directory > "$$logfile" 2>&1 ); then \
			echo "✓ Success"; \
			rm -f "$$logfile"; \
		else \
			echo "✗ Failed"; \
			echo "----- Build log for module '$$mod' -----"; \
			cat "$$logfile"; \
			echo "----------------------------------------"; \
			exit 1; \
		fi; \
	done


.PHONY: force_main
force_main: $(MAIN_OBJ)

.PHONY: rebuild_main

rebuild_main:
	@echo "→ Rebuilding main.cpp and final link"
	@mkdir -p $(dir $(MAIN_OBJ))
	$(CXX) $(CXXFLAGS) -c $(MAIN_SRC) -o $(MAIN_OBJ)
	@logfile="/tmp/build_main_relink.log"; \
	if $(CXX) $(CXXFLAGS) -o $(OUT) $(OBJ_CPP) $(OBJ_C) $(MAIN_OBJ) -Wl,--whole-archive $(STATIC_LIBS) -Wl,--no-whole-archive > "$$logfile" 2>&1; then \
		echo "✓ Main Executable Rebuilt Successfully"; \
		rm -f "$$logfile"; \
	else \
		echo "✗ Failed to rebuild main executable"; \
		cat "$$logfile"; \
		exit 1; \
	fi


$(MAIN_OBJ): $(MAIN_SRC)
	@mkdir -p $(dir $@)
	$(CXX) $(CXXFLAGS) -c $< -o $@
# ------------------------------------------------------------------------------
# 2) Link main program
# ------------------------------------------------------------------------------
$(OUT): modules $(OBJ_CPP) $(OBJ_C) force_main $(STATIC_LIBS)
	@echo "→ Building Main Executable"
	@logfile="/tmp/build_main.log"; \
	if $(CXX) $(CXXFLAGS) -o $@ $(OBJ_CPP) $(OBJ_C) $(MAIN_OBJ) -Wl,--whole-archive $(STATIC_LIBS) -Wl,--no-whole-archive > "$$logfile" 2>&1; then \
		echo "✓ Main Executable Built Successfully"; \
		rm -f "$$logfile"; \
	else \
		echo "✗ Failed to build main executable"; \
		echo "----- Main Build Log -----"; \
		cat "$$logfile"; \
		echo "---------------------------"; \
		exit 1; \
	fi

# ------------------------------------------------------------------------------
# 3) Compile rules for main program sources and extra custom sources
# ------------------------------------------------------------------------------
# Rule to compile C++ source files into object files
build/%.o: %.cpp
	@mkdir -p $(dir $@)
	$(CXX) $(CXXFLAGS) -c $< -o $@

# Rule to compile C source files into object files
build/%.o: %.c
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -c $< -o $@

# ------------------------------------------------------------------------------
# 4) Scaffold a new module: `make module NAME=foo`
# ------------------------------------------------------------------------------
.PHONY: module
module:
ifeq ($(strip $(NAME)),)
	$(error Usage: make module NAME=module_name)
endif
	@echo "→ Scaffolding new module: '$(NAME)'"
	mkdir -p custom_modules/$(NAME)
	cp template_module/Makefile.template custom_modules/$(NAME)/Makefile
	cp template_module/module.cpp.template custom_modules/$(NAME)/module.cpp
	sed $(SED_INPLACE) -e "s/__MODULE_NAME__/$(NAME)/g" custom_modules/$(NAME)/module.cpp
	printf "name     = $(NAME)\n" > custom_modules/$(NAME)/module.info
	printf "priority = 2\n" >> custom_modules/$(NAME)/module.info
	printf "depends  =\n" >> custom_modules/$(NAME)/module.info
	@echo "Module '$(NAME)' scaffolded successfully in custom_modules/$(NAME)"

# ------------------------------------------------------------------------------
# 5) Clean everything
# ------------------------------------------------------------------------------
.PHONY: clean
clean:
	@echo "→ Cleaning project…"
	rm -rf $(OUT) build/
	find . -name '*.o' -delete
	@for d in $(MODULE_DIRS); do \
		echo "   • Cleaning module in $$d"; \
		$(MAKE) -C $$d clean || { echo "Warning: Failed to clean module in $$d. Continuing..."; }; \
	done
	rm -f /tmp/modules_info.txt
	@echo "Clean complete."
